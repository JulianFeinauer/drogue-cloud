:icons: font

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

:toc:
:toc-placement!:

= Digital twin

NOTE: All commands are relative to the root of the repository.

'''

toc::[]

== Setup

=== Install pre-reqs

The digital twin requires a few pre-requisites.

==== MongoDO

A MongoDB instance is required by Ditto for persisting device state information:

----
helm repo add bitnami https://charts.bitnami.com/bitnami
helm install mongodb bitnami/mongodb --set podSecurityContext.enabled=false --set containerSecurityContext.enabled=false --set auth.rootPassword=admin123456 --set auth.enabled=false
----

==== Ditto Operator

Install the Ditto operator using Helm:

    helm repo add helm-charts https://ctron.github.io/helm-charts/
    helm install ditto-operator helm-charts/ditto-operator --version 0.1.7

NOTE: It is also possible to install the Ditto operator using OLM.

==== Vorto API token (optional)

NOTE: This step is not required by the default example in this tutorial. However, you might need it, if you want
to further experiment with Ditto and Vorto.

If you want to use private models or mappings from the Vorto repository, you will need to register an account at
https://vorto.eclipse.org. The account will be backed  by another identity  provider (e.g. GitHub), and you
will need to create an access token for this identity, using the chosen identity provider.

Assuming you are using GitHub as identity provider, you need to create a GitHub personal access token, granting
the following permissions:

* `read:user`
* `user:email`

With this token create a Kubernetes secret using the following command (be sure to replace `<my-token>`):

----
kubectl create secret generic vorto-api --from-literal=token=<my-token>
----

=== Deploy

Deploy all components using:

----
# plain Kubernetes
helm -n drogue-iot install --dependency-update --wait --timeout 15m digital-twin deploy/helm/digital-twin

# OpenShift, with routes
helm -n drogue-iot install --file deploy/helm/digital-twin/profile-openshift.yaml --dependency-update --wait --timeout 15m digital-twin deploy/helm/digital-twin
----

[TIP]
.Environment variables
====
When the `helm` command succeeds, it will print out a set of shell statements, which set some environment
variables with their expected values. These variables will be used later on in this tutorial, so you can simply
execute these statements and don't need to set the environment variables manually later on.
====

== Using

=== Create a device in Ditto

First you need to create a device in Ditto. For this we need the description of the device. The description is
stored in the public Vorto repository (https://vorto.eclipse.org), and the device description can be exported
using the following command:

----
MODEL_ID=io.drogue.demo:FirstTestDevice:1.0.0

http -do FirstTestDevice.json https://vorto.eclipse.org/api/v1/generators/eclipseditto/models/$MODEL_ID/?target=thingJson
----

This will store the device description in the file `FirstTestDevice.json` of your local file system. The content
should look like:

[source,json]
----
{
  "definition": "io.drogue.demo:FirstTestDevice:1.0.0",
  "attributes": {
    "modelDisplayName": "FirstTestDevice"
  },
  "features": {
    "temperature": {
      "definition": [
        "org.eclipse.vorto.std.sensor:TemperatureSensor:1.0.0"
      ],
      "properties": {
        "status": {
          "value": 0
        }
      }
    }
  }
}
----

With this device description, we can create a new device in the Ditto system:

----
DEVICE_ID=my:dev1

cat FirstTestDevice.json | http PUT "https://ditto:ditto@ditto-console-drogue-iot.apps.my.cluster/api/2/things/$DEVICE_ID"
----

As a result, you should receive:

----
HTTP/1.1 201 Created
…
----

If the device already existed in the Ditto system, then it would update the device with the newly provided
definition and instead return:

----
HTTP/1.1 204 No Content
…
----

=== Publish data

----
ENDPOINT="https://http-endpoint-drogue-iot.apps.my.cluster"
DEVICE_ID="my:dev1"
CHANNEL="foo"
MODEL_ID="io.drogue.demo:FirstTestDevice:1.0.0"

http -v POST "${ENDPOINT}/publish/${DEVICE_ID}/${CHANNEL}" "model_id==$MODEL_ID" temp:=1.23
----

NOTE: You can use the script `./hack/publish_loop.sh` to generate a constant stream of simulated temperature readings.

=== Fetch from Ditto

The simulated temperature readings are now published to the HTTP endpoint. On reception, the data is still directly
stored in the Kafka stream. Additionally to InfluxDB, it will now be also available in the Ditto instance. You can
retrieve the current state of the device using the following command:

The published temperature readings that are now published to the HTTP endpoint are still stored in the original
Kafka stream. Additionally to InfluxDB, they are now processed by a second consumer, which will first translate
the payload using the Vorto converter, and then forward the normalized payload to the Ditto instance.

----
http "https://ditto:ditto@ditto-console-drogue-iot.apps.my.cluster/api/2/things/my:dev1"
----

This should return the current state, in the normalized Ditto format:

[source,json]
----
{
    "attributes": {
        "modelDisplayName": "FirstTestDevice"
    },
    "definition": "io.drogue.demo:FirstTestDevice:1.0.0",
    "features": {
        "temperature": {
            "definition": [
                "org.eclipse.vorto.std.sensor:TemperatureSensor:1.0.0"
            ],
            "properties": {
                "status": {
                    "value": 0.052751
                }
            }
        }
    },
    "policyId": "my:dev1",
    "thingId": "my:dev1"
}
----

== What just

== Additionally
